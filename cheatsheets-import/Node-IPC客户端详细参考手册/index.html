<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node-IPCå®¢æˆ·ç«¯è¯¦ç»†å‚è€ƒæ‰‹å†Œ</title>
</head>
<body>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node-IPC å®¢æˆ·ç«¯è¯¦ç»†å‚è€ƒæ‰‹å†Œ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
            line-height: 1.4;
            margin: 2rem;
            color: #333;
            background: #fafafa;
            font-size: 12px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            font-size: 2.2rem;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        h2 {
            font-size: 1.5rem;
            color: #2c3e50;
            margin: 2rem 0 1rem 0;
            padding: 0.5rem 0;
            border-left: 4px solid #3498db;
            padding-left: 1rem;
            background: #f8f9fa;
        }
        h3 {
            font-size: 1.2rem;
            color: #34495e;
            margin: 1.5rem 0 0.8rem 0;
        }
        code {
            font-family: "Fira Code", "Source Code Pro", Consolas, Monaco, monospace;
            background: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9rem;
            border: 1px solid #e1e1e1;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            line-height:1.1;
            padding: 1.5rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            border: 1px solid #4a5568;
        }
        pre code {
            background: none;
            border: none;
            padding: 0;
            color: inherit;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: white;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #e1e8ed;
            padding: 0.8rem 1rem;
            text-align: left;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        .highlight {
            background: #fff3cd;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-weight: 600;
            color: #856404;
        }
        .warning {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            color: #721c24;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            color: #0c5460;
        }
        .tip {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            color: #155724;
        }
        ul, ol {
            padding-left: 2rem;
        }
        li {
            margin: 0.5rem 0;
        }
        .method-signature {
            background: #e8f4fd;
            padding: 0.5rem;
            border-left: 4px solid #3498db;
            margin: 1rem 0;
            font-family: monospace;
        }
        .example-section {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        /* Code Highlighting Styles */
        .hljs {
            display: block;
            overflow-x: auto;
            padding: 0.5em;
            background: #2d3748; /* Dark background from pre tag */
            color: #e2e8f0; /* Light text color from pre tag */
        }
        .hljs-comment,
        .hljs-quote {
            color: #6c7280; /* Grey for comments */
            font-style: italic;
        }
        .hljs-keyword,
        .hljs-selector-tag,
        .hljs-literal,
        .hljs-title,
        .hljs-name {
            color: #f1fa8c; /* Yellow for keywords */
        }
        .hljs-type,
        .hljs-string,
        .hljs-regexp,
        .hljs-meta,
        .hljs-link {
            color: #8affac; /* Greenish for strings */
        }
        .hljs-current-line,
        .hljs-selection {
            background-color: #374151; /* Slightly lighter background for selection */
        }
        .hljs-bullet,
        .hljs-attribute {
            color: #8affac; /* Greenish for attributes */
        }
        .hljs-built_in,
        .hljs-title.function_ {
            color: #80aaff; /* Blue for built-ins and function names */
        }
        .hljs-formula,
        .hljs-number,
        .hljs-symbol {
            color: #bd93f9; /* Purple for numbers and symbols */
        }
        .hljs-variable,
        .hljs-template-variable {
            color: #ff9580; /* Reddish for variables */
        }
        .hljs-meta-keyword {
            color: #ffc280; /* Orange for meta keywords */
        }
        .hljs-emphasis {
            font-style: italic;
        }
        .hljs-strong {
            font-weight: bold;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css">


    <div class="container">
        <h1>ğŸš€ Node-IPC å®¢æˆ·ç«¯è¯¦ç»†å‚è€ƒæ‰‹å†Œ</h1>

        <div class="info">
            <strong>ğŸ“– æ–‡æ¡£è¯´æ˜ï¼š</strong>æœ¬æ‰‹å†ŒåŸºäº node-ipc v11.x+ å®˜æ–¹æ–‡æ¡£ç¼–å†™ï¼Œä¸“æ³¨äºå®¢æˆ·ç«¯åŠŸèƒ½çš„è¯¦ç»†ä½¿ç”¨æŒ‡å—ã€‚<br>
            <strong>ğŸ”— å®˜æ–¹ä»“åº“ï¼š</strong> <code>https://github.com/RIAEvangelist/node-ipc</code><br>
            <strong>ğŸ“¦ å®‰è£…å‘½ä»¤ï¼š</strong> <code>npm install node-ipc</code>
        </div>

        <h2>1. åŸºç¡€å¯¼å…¥ä¸é…ç½®</h2>

        <h3>1.1 æ¨¡å—å¯¼å…¥æ–¹å¼</h3>
        <pre><code class="language-javascript">// ES6 æ¨¡å—å¯¼å…¥
import ipc from 'node-ipc';

// CommonJS å¯¼å…¥
const ipc = require('node-ipc');

// è§£æ„å¯¼å…¥ç‰¹å®šåŠŸèƒ½
const { config, connectTo, of } = require('node-ipc');</code></pre>

        <h3>1.2 å…¨å±€é…ç½®è¯¦è§£</h3>
        <div class="example-section">
            <h4>å®Œæ•´é…ç½®ç¤ºä¾‹</h4>
            <pre><code class="language-javascript">// åŸºç¡€é…ç½®
ipc.config.id = 'myClientApp';           // å®¢æˆ·ç«¯å”¯ä¸€æ ‡è¯†ç¬¦
ipc.config.retry = 1500;                   // é‡è¿é—´éš”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
ipc.config.maxRetries = 10;                // æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œ0ä¸ºæ— é™æ¬¡
ipc.config.silent = false;                 // æ˜¯å¦é™é»˜æ¨¡å¼ï¼ˆä¸è¾“å‡ºæ—¥å¿—ï¼‰

// ç½‘ç»œé…ç½®
ipc.config.networkHost = 'localhost';      // é»˜è®¤TCP/UDPä¸»æœº
ipc.config.networkPort = 8000;             // é»˜è®¤ç«¯å£
ipc.config.encoding = 'utf8';              // æ•°æ®ç¼–ç æ ¼å¼

// é«˜çº§é…ç½®
ipc.config.rawBuffer = false;              // æ˜¯å¦è¿”å›åŸå§‹Buffer
ipc.config.delimiter = false;              // æ¶ˆæ¯åˆ†éš”ç¬¦ï¼Œå¦‚ '\f'
ipc.config.appspace = '';                  // åº”ç”¨å‘½åç©ºé—´å‰ç¼€
ipc.config.socketRoot = '/tmp/';           // Unix socketæ ¹ç›®å½•

// UDPç‰¹å®šé…ç½®
ipc.config.udpType = 'udp4';               // UDPç±»å‹ï¼š'udp4' æˆ– 'udp6'

// TLSé…ç½®ï¼ˆä»…ç”¨äºTLSè¿æ¥ï¼‰
ipc.config.tls = {
    key: fs.readFileSync('client-key.pem'),
    cert: fs.readFileSync('client-cert.pem'),
    ca: fs.readFileSync('ca-cert.pem'),
    rejectUnauthorized: true
};</code></pre>
        </div>

        <h2>2. è¿æ¥æ–¹å¼è¯¦è§£</h2>

        <table>
            <thead>
                <tr>
                    <th>è¿æ¥æ–¹æ³•</th>
                    <th>ä½¿ç”¨åœºæ™¯</th>
                    <th>æ€§èƒ½ç‰¹ç‚¹</th>
                    <th>å®‰å…¨æ€§</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>connectTo()</code></td>
                    <td>æœ¬åœ°è¿›ç¨‹é—´é€šä¿¡</td>
                    <td>âš¡ æå¿«ï¼ˆç»•è¿‡ç½‘ç»œæ ˆï¼‰</td>
                    <td>ğŸ”’ é«˜ï¼ˆæœ¬åœ°æ–‡ä»¶ç³»ç»Ÿæƒé™ï¼‰</td>
                </tr>
                <tr>
                    <td><code>connectToNet()</code></td>
                    <td>è·¨ç½‘ç»œTCPé€šä¿¡</td>
                    <td>ğŸŒ è¾ƒæ…¢ä½†å¯é </td>
                    <td>âš ï¸ æ˜æ–‡ä¼ è¾“</td>
                </tr>
                <tr>
                    <td><code>connectToNetTLS()</code></td>
                    <td>å®‰å…¨TCPé€šä¿¡</td>
                    <td>ğŸŒ æ…¢ï¼ˆåŠ å¯†å¼€é”€ï¼‰</td>
                    <td>ğŸ” é«˜ï¼ˆSSL/TLSåŠ å¯†ï¼‰</td>
                </tr>
                <tr>
                    <td><code>connectToUDP()</code></td>
                    <td>é«˜é€Ÿä¸å¯é é€šä¿¡</td>
                    <td>ğŸš€ æœ€å¿«</td>
                    <td>âš ï¸ æ— è¿æ¥çŠ¶æ€</td>
                </tr>
            </tbody>
        </table>

        <h3>2.1 Unix Socketè¿æ¥ï¼ˆæœ¬åœ°IPCï¼‰</h3>
        <div class="example-section">
            <div class="method-signature">
                ipc.connectTo(serverID, callback)
            </div>
            <pre><code class="language-javascript">// åŸºç¡€Unix Socketè¿æ¥
ipc.config.id = 'client-001';
ipc.config.socketRoot = '/tmp/myapp/';     // è‡ªå®šä¹‰socketç›®å½•

ipc.connectTo('gameServer', function() {
    const server = ipc.of.gameServer;
    
    // è¿æ¥ç”Ÿå‘½å‘¨æœŸäº‹ä»¶
    server.on('connect', function() {
        console.log('ğŸ”— å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨');
        // è¿æ¥æˆåŠŸåç«‹å³å‘é€è®¤è¯ä¿¡æ¯
        server.emit('auth', {
            token: 'user-token-123',
            clientVersion: '1.2.0'
        });
    });
    
    server.on('disconnect', function() {
        console.log('âŒ ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
    });
    
    // æ¸¸æˆæ•°æ®å¤„ç†
    server.on('playerUpdate', function(data) {
        console.log('ç©å®¶æ›´æ–°:', data);
        updateGameUI(data);
    });
    
    // é”™è¯¯å¤„ç†
    server.on('error', function(err) {
        console.error('è¿æ¥é”™è¯¯:', err.message);
    });
});</code></pre>
        </div>

        <h3>2.2 TCPç½‘ç»œè¿æ¥</h3>
        <div class="example-section">
            <div class="method-signature">
                ipc.connectToNet(serverID, host, port, callback)
            </div>
            <pre><code class="language-javascript">// TCPè¿æ¥åˆ°è¿œç¨‹æœåŠ¡å™¨
ipc.connectToNet('apiServer', '192.168.1.100', 9001, function() {
    const api = ipc.of.apiServer;
    
    api.on('connect', function() {
        console.log('ğŸŒ TCPè¿æ¥å»ºç«‹');
        
        // å‘é€APIè¯·æ±‚
        api.emit('getUsers', {
            page: 1,
            limit: 50,
            filters: { active: true }
        });
    });
    
    api.on('usersResponse', function(response) {
        if (response.success) {
            console.log(`è·å–åˆ° ${response.data.length} ä¸ªç”¨æˆ·`);
            processUsers(response.data);
        } else {
            console.error('APIé”™è¯¯:', response.error);
        }
    });
    
    // å¤„ç†ç½‘ç»œè¶…æ—¶
    api.on('disconnect', function() {
        console.log('ğŸ”Œ TCPè¿æ¥æ–­å¼€ï¼Œå°†åœ¨ 1.5 ç§’åé‡è¯•');
    });
});</code></pre>
        </div>

        <h3>2.3 TLSå®‰å…¨è¿æ¥</h3>
        <div class="example-section">
            <div class="method-signature">
                ipc.connectToNetTLS(serverID, host, port, callback)
            </div>
            <pre><code class="language-javascript">// é…ç½®TLSè¯ä¹¦
ipc.config.tls = {
    key: fs.readFileSync('./certs/client-key.pem'),
    cert: fs.readFileSync('./certs/client-cert.pem'),
    ca: fs.readFileSync('./certs/ca.pem'),
    rejectUnauthorized: true,
    checkServerIdentity: function(host, cert) {
        // è‡ªå®šä¹‰æœåŠ¡å™¨èº«ä»½éªŒè¯é€»è¾‘
        return undefined; // è¿”å›undefinedè¡¨ç¤ºéªŒè¯é€šè¿‡
    }
};

// å»ºç«‹å®‰å…¨è¿æ¥
ipc.connectToNetTLS('secureAPI', 'secure.example.com', 8443, function() {
    const secureConn = ipc.of.secureAPI;
    
    secureConn.on('connect', function() {
        console.log('ğŸ” TLSå®‰å…¨è¿æ¥å»ºç«‹');
        
        // å‘é€æ•æ„Ÿæ•°æ®
        secureConn.emit('sensitiveOperation', {
            userId: 12345,
            operation: 'transfer',
            amount: 1000,
            signature: generateSignature()
        });
    });
    
    secureConn.on('operationResult', function(result) {
        if (result.status === 'success') {
            console.log('âœ… æ“ä½œæˆåŠŸ:', result.transactionId);
        } else {
            console.error('âŒ æ“ä½œå¤±è´¥:', result.reason);
        }
    });
});</code></pre>
        </div>

        <h3>2.4 UDPé«˜é€Ÿé€šä¿¡</h3>
        <div class="example-section">
            <div class="method-signature">
                ipc.connectToUDP(serverID, host, port, callback)
            </div>
            <pre><code class="language-javascript">// UDPé…ç½®
ipc.config.udpType = 'udp4';
ipc.config.rawBuffer = true; // UDPé€šå¸¸ä½¿ç”¨åŸå§‹ç¼“å†²åŒº

ipc.connectToUDP('gameStream', '192.168.1.50', 7777, function() {
    const stream = ipc.of.gameStream;
    
    stream.on('connect', function() {
        console.log('ğŸš€ UDPæ•°æ®æµè¿æ¥å»ºç«‹');
        
        // å¼€å§‹æ¥æ”¶æ¸¸æˆçŠ¶æ€æ›´æ–°
        const heartbeat = setInterval(() => {
            stream.emit('ping', Buffer.from(JSON.stringify({
                clientId: ipc.config.id,
                timestamp: Date.now()
            })));
        }, 100); // æ¯100mså‘é€å¿ƒè·³
        
        // æ¸…ç†å®šæ—¶å™¨
        stream.on('disconnect', () => clearInterval(heartbeat));
    });
    
    // å¤„ç†æ¸¸æˆçŠ¶æ€æ•°æ®
    stream.on('message', function(buffer) {
        try {
            const gameState = JSON.parse(buffer.toString());
            updateGameWorld(gameState);
        } catch (err) {
            console.error('æ•°æ®è§£æé”™è¯¯:', err);
        }
    });
    
    // UDPç‰¹å®šï¼šå¤„ç†æ•°æ®åŒ…ä¸¢å¤±
    let lastSequence = 0;
    stream.on('gameState', function(data) {
        if (data.sequence > lastSequence + 1) {
            console.warn(`æ£€æµ‹åˆ°æ•°æ®åŒ…ä¸¢å¤±: ${lastSequence + 1} åˆ° ${data.sequence - 1}`);
        }
        lastSequence = data.sequence;
    });
});</code></pre>
        </div>

        <h2>3. æ¶ˆæ¯å¤„ç†æœºåˆ¶</h2>

        <h3>3.1 äº‹ä»¶ç›‘å¬ä¸å¤„ç†</h3>
        <div class="example-section">
            <pre><code class="language-javascript">const socket = ipc.of.serverName;

// åŸºç¡€äº‹ä»¶ç›‘å¬
socket.on('customEvent', function(data) {
    console.log('æ¥æ”¶åˆ°è‡ªå®šä¹‰äº‹ä»¶:', data);
});

// ä¸€æ¬¡æ€§äº‹ä»¶ç›‘å¬
socket.once('initialization', function(config) {
    console.log('æœåŠ¡å™¨åˆå§‹åŒ–é…ç½®:', config);
    applyServerConfig(config);
});

// ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
function tempHandler(data) {
    console.log('ä¸´æ—¶å¤„ç†å™¨:', data);
}
socket.on('tempEvent', tempHandler);
// ç¨åç§»é™¤
socket.off('tempEvent', tempHandler);

// ç›‘å¬æ‰€æœ‰äº‹ä»¶ï¼ˆè°ƒè¯•ç”¨ï¼‰
socket.onAny(function(eventName, ...args) {
    console.log(`äº‹ä»¶: ${eventName}`, args);
});</code></pre>
        </div>

        <h3>3.2 å†…ç½®ç”Ÿå‘½å‘¨æœŸäº‹ä»¶</h3>
        <table>
            <thead>
                <tr>
                    <th>äº‹ä»¶åç§°</th>
                    <th>è§¦å‘æ—¶æœº</th>
                    <th>å‚æ•°</th>
                    <th>ä½¿ç”¨åœºæ™¯</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>connect</code></td>
                    <td>æˆåŠŸè¿æ¥åˆ°æœåŠ¡å™¨</td>
                    <td>æ— </td>
                    <td>åˆå§‹åŒ–ã€å‘é€è®¤è¯ä¿¡æ¯</td>
                </tr>
                <tr>
                    <td><code>disconnect</code></td>
                    <td>ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥</td>
                    <td>æ— </td>
                    <td>æ¸…ç†èµ„æºã€æ˜¾ç¤ºæ–­çº¿æç¤º</td>
                </tr>
                <tr>
                    <td><code>destroy</code></td>
                    <td>è¿æ¥è¢«å½»åº•é”€æ¯</td>
                    <td>æ— </td>
                    <td>æœ€ç»ˆæ¸…ç†ã€é‡Šæ”¾å†…å­˜</td>
                </tr>
                <tr>
                    <td><code>error</code></td>
                    <td>è¿æ¥æˆ–é€šä¿¡é”™è¯¯</td>
                    <td>Errorå¯¹è±¡</td>
                    <td>é”™è¯¯å¤„ç†ã€é‡è¿é€»è¾‘</td>
                </tr>
                <tr>
                    <td><code>data</code></td>
                    <td>æ¥æ”¶åˆ°åŸå§‹æ•°æ®</td>
                    <td>Buffer</td>
                    <td>åº•å±‚æ•°æ®å¤„ç†</td>
                </tr>
            </tbody>
        </table>

        <h3>3.3 æ¶ˆæ¯å‘é€æ–¹å¼</h3>
        <div class="example-section">
            <pre><code class="language-javascript">const socket = ipc.of.serverName;

// 1. å‘é€JSONå¯¹è±¡ï¼ˆè‡ªåŠ¨åºåˆ—åŒ–ï¼‰
socket.emit('userAction', {
    action: 'login',
    credentials: {
        username: 'john_doe',
        password: 'hashed_password'
    },
    metadata: {
        userAgent: 'MyApp/1.0',
        timestamp: Date.now()
    }
});

// 2. å‘é€åŸå§‹å­—ç¬¦ä¸²
socket.emit('message', 'Hello Server!');

// 3. å‘é€äºŒè¿›åˆ¶æ•°æ®
const binaryData = Buffer.from([0x48, 0x65, 0x6C, 0x6C, 0x6F]);
socket.emit('binaryMessage', binaryData);

// 4. æ‰¹é‡å‘é€å¤šä¸ªæ¶ˆæ¯
const messages = [
    { type: 'status', data: 'online' },
    { type: 'position', data: { x: 100, y: 200 } },
    { type: 'inventory', data: ['sword', 'shield'] }
];

messages.forEach((msg, index) => {
    setTimeout(() => {
        socket.emit(msg.type, msg.data);
    }, index * 10); // é—´éš”10mså‘é€
});

// 5. æ¡ä»¶å‘é€
function sendIfConnected(event, data) {
    if (socket.connected) {
        socket.emit(event, data);
    } else {
        console.warn('è¿æ¥æœªå»ºç«‹ï¼Œæ¶ˆæ¯å·²ä¸¢å¼ƒ:', event, data);
    }
}</code></pre>
        </div>

        <h2>4. é«˜çº§åŠŸèƒ½ä¸æœ€ä½³å®è·µ</h2>

        <h3>4.1 è¿æ¥ç®¡ç†ä¸é‡è¿æœºåˆ¶</h3>
        <div class="example-section">
            <pre><code class="language-javascript">class IPCClient {
    constructor(serverId, options = {}) {
        this.serverId = serverId;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = options.maxReconnectAttempts || 5;
        this.reconnectDelay = options.reconnectDelay || 1000;
        
        // é…ç½®IPC
        ipc.config.id = options.clientId || 'client-' + Date.now();
        ipc.config.retry = this.reconnectDelay;
        ipc.config.maxRetries = this.maxReconnectAttempts;
        ipc.config.silent = options.silent || false;
    }
    
    connect() {
        return new Promise((resolve, reject) => {
            ipc.connectTo(this.serverId, () => {
                const socket = ipc.of[this.serverId];
                
                socket.on('connect', () => {
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    console.log(`âœ… è¿æ¥åˆ°æœåŠ¡å™¨ ${this.serverId}`);
                    resolve(socket);
                });
                
                socket.on('disconnect', () => {
                    this.isConnected = false;
                    console.log(`âŒ ä¸æœåŠ¡å™¨ ${this.serverId} æ–­å¼€è¿æ¥`);
                    this.handleReconnect();
                });
                
                socket.on('error', (err) => {
                    console.error('è¿æ¥é”™è¯¯:', err);
                    if (!this.isConnected) {
                        reject(err);
                    }
                });
            });
        });
    }
    
    handleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            console.log(`ğŸ”„ ${delay}ms åè¿›è¡Œç¬¬ ${this.reconnectAttempts} æ¬¡é‡è¿...`);
            
            setTimeout(() => {
                this.connect().catch(() => {
                    // é‡è¿å¤±è´¥ï¼Œç»§ç»­é‡è¯•
                });
            }, delay);
        } else {
            console.error(`âŒ é‡è¿å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° ${this.maxReconnectAttempts}`);
        }
    }
    
    disconnect() {
        if (this.isConnected) {
            ipc.disconnect(this.serverId);
            this.isConnected = false;
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const client = new IPCClient('gameServer', {
    clientId: 'player-12345',
    maxReconnectAttempts: 10,
    reconnectDelay: 2000,
    silent: false
});

client.connect().then(socket => {
    socket.on('gameData', handleGameData);
    socket.emit('joinGame', { playerId: 'player-12345' });
}).catch(err => {
    console.error('è¿æ¥å¤±è´¥:', err);
});</code></pre>
        </div>

        <h3>4.2 æ•°æ®åºåˆ—åŒ–ä¸éªŒè¯</h3>
        <div class="example-section">
            <pre><code class="language-javascript">// è‡ªå®šä¹‰åºåˆ—åŒ–å™¨
class MessageSerializer {
    static serialize(data) {
        try {
            return JSON.stringify({
                timestamp: Date.now(),
                version: '1.0',
                payload: data,
                checksum: this.calculateChecksum(data)
            });
        } catch (err) {
            console.error('åºåˆ—åŒ–å¤±è´¥:', err);
            return null;
        }
    }
    
    static deserialize(rawData) {
        try {
            const message = JSON.parse(rawData);
            
            // éªŒè¯æ¶ˆæ¯ç»“æ„
            if (!message.timestamp || !message.payload) {
                throw new Error('æ¶ˆæ¯æ ¼å¼æ— æ•ˆ');
            }
            
            // éªŒè¯æ ¡éªŒå’Œ
            if (message.checksum !== this.calculateChecksum(message.payload)) {
                throw new Error('æ¶ˆæ¯æ ¡éªŒå¤±è´¥');
            }
            
            // æ£€æŸ¥æ¶ˆæ¯æ–°é²œåº¦ï¼ˆ10ç§’å†…ï¼‰
            if (Date.now() - message.timestamp > 10000) {
                throw new Error('æ¶ˆæ¯è¿‡æœŸ');
            }
            
            return message.payload;
        } catch (err) {
            console.error('ååºåˆ—åŒ–å¤±è´¥:', err);
            return null;
        }
    }
    
    static calculateChecksum(data) {
        // ç®€å•çš„æ ¡éªŒå’Œè®¡ç®—
        const str = JSON.stringify(data);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
        }
        return hash;
    }
}

// åœ¨IPCå®¢æˆ·ç«¯ä¸­ä½¿ç”¨
socket.on('connect', function() {
    // å‘é€åºåˆ—åŒ–æ¶ˆæ¯
    const message = MessageSerializer.serialize({
        type: 'userLogin',
        data: { userId: 123, token: 'abc123' }
    });
    
    if (message) {
        socket.emit('secureMessage', message);
    }
});

socket.on('secureResponse', function(rawData) {
    const data = MessageSerializer.deserialize(rawData);
    if (data) {
        console.log('å®‰å…¨æ¶ˆæ¯æ¥æ”¶æˆåŠŸ:', data);
    }
});</code></pre>
        </div>

        <h3>4.3 æ€§èƒ½ç›‘æ§ä¸è°ƒè¯•</h3>
        <div class="example-section">
            <pre><code class="language-javascript">class IPCPerformanceMonitor {
    constructor(socket) {
        this.socket = socket;
        this.metrics = {
            messagesSent: 0,
            messagesReceived: 0,
            bytesTransferred: 0,
            latencyHistory: [],
            errorCount: 0
        };
        this.startTime = Date.now();
        
        this.setupMonitoring();
    }
    
    setupMonitoring() {
        // ç›‘æ§å‘é€çš„æ¶ˆæ¯
        const originalEmit = this.socket.emit;
        this.socket.emit = (event, data) => {
            this.metrics.messagesSent++;
            if (data) {
                this.metrics.bytesTransferred += JSON.stringify(data).length;
            }
            
            // æµ‹é‡å»¶è¿Ÿï¼ˆå¦‚æœæ˜¯pingæ¶ˆæ¯ï¼‰
            if (event === 'ping') {
                data._sendTime = Date.now();
            }
            
            return originalEmit.call(this.socket, event, data);
        };
        
        // ç›‘æ§æ¥æ”¶çš„æ¶ˆæ¯
        this.socket.onAny((event, data) => {
            this.metrics.messagesReceived++;
            
            // è®¡ç®—pingå»¶è¿Ÿ
            if (event === 'pong' && data._sendTime) {
                const latency = Date.now() - data._sendTime;
                this.metrics.latencyHistory.push(latency);
                
                // åªä¿ç•™æœ€è¿‘100æ¬¡çš„å»¶è¿Ÿè®°å½•
                if (this.metrics.latencyHistory.length > 100) {
                    this.metrics.latencyHistory.shift();
                }
            }
        });
        
        // ç›‘æ§é”™è¯¯
        this.socket.on('error', () => {
            this.metrics.errorCount++;
        });
    }
    
    getStats() {
        const uptime = Date.now() - this.startTime;
        const avgLatency = this.metrics.latencyHistory.length > 0 
            ? this.metrics.latencyHistory.reduce((a, b) => a + b) / this.metrics.latencyHistory.length 
            : 0;
            
        return {
            uptime: Math.floor(uptime / 1000), // ç§’
            messagesSent: this.metrics.messagesSent,
            messagesReceived: this.metrics.messagesReceived,
            bytesTransferred: this.metrics.bytesTransferred,
            averageLatency: Math.round(avgLatency), // æ¯«ç§’
            errorCount: this.metrics.errorCount,
            messagesPerSecond: Math.round((this.metrics.messagesSent + this.metrics.messagesReceived) / (uptime / 1000))
        };
    }
    
    startPeriodicReport(intervalSeconds = 30) {
        setInterval(() => {
            const stats = this.getStats();
            console.log('ğŸ“Š IPCæ€§èƒ½ç»Ÿè®¡:', stats);
        }, intervalSeconds * 1000);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
ipc.connectTo('server', function() {
    const socket = ipc.of.server;
    const monitor = new IPCPerformanceMonitor(socket);
    
    socket.on('connect', () => {
        monitor.startPeriodicReport(10); // æ¯10ç§’è¾“å‡ºä¸€æ¬¡ç»Ÿè®¡
        
        // å‘é€å®šæœŸpingæµ‹è¯•å»¶è¿Ÿ
        setInterval(() => {
            socket.emit('ping', { _sendTime: Date.now() });
        }, 5000);
    });
});</code></pre>
        </div>

        <h2>5. é”™è¯¯å¤„ç†ä¸æ•…éšœæ’é™¤</h2>

        <div class="warning">
            <strong>âš ï¸ å¸¸è§é”™è¯¯ç±»å‹ï¼š</strong>
            <ul>
                <li><strong>ENOENT:</strong> Unix socketæ–‡ä»¶ä¸å­˜åœ¨ï¼ˆæœåŠ¡å™¨æœªå¯åŠ¨ï¼‰</li>
                <li><strong>ECONNREFUSED:</strong> TCPè¿æ¥è¢«æ‹’ç»ï¼ˆç«¯å£æœªç›‘å¬ï¼‰</li>
                <li><strong>EADDRINUSE:</strong> åœ°å€è¢«å ç”¨ï¼ˆç«¯å£å†²çªï¼‰</li>
                <li><strong>ETIMEDOUT:</strong> è¿æ¥è¶…æ—¶ï¼ˆç½‘ç»œé—®é¢˜ï¼‰</li>
                <li><strong>EPIPE:</strong> ç®¡é“ç ´è£‚ï¼ˆå¯¹ç«¯å¼‚å¸¸å…³é—­ï¼‰</li>
            </ul>
        </div>

        <h3>5.1 å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶</h3>
        <div class="example-section">
            <pre><code class="language-javascript">class RobustIPCClient {
    constructor(serverId, options = {}) {
        this.serverId = serverId;
        this.options = options;
        this.connectionState = 'disconnected'; // disconnected, connecting, connected
        this.lastError = null;
        this.errorHandlers = new Map();
        
        this.setupErrorHandling();
    }
    
    setupErrorHandling() {
        // æ³¨å†Œå„ç§é”™è¯¯å¤„ç†å™¨
        this.errorHandlers.set('ENOENT', (err) => {
            console.error('âŒ æœåŠ¡å™¨æœªå¯åŠ¨æˆ–socketæ–‡ä»¶ä¸å­˜åœ¨');
            return { shouldRetry: true, delay: 2000 };
        });
        
        this.errorHandlers.set('ECONNREFUSED', (err) => {
            console.error('âŒ è¿æ¥è¢«æ‹’ç»ï¼Œæ£€æŸ¥æœåŠ¡å™¨ç«¯å£');
            return { shouldRetry: true, delay: 5000 };
        });
        
        this.errorHandlers.set('ETIMEDOUT', (err) => {
            console.error('âŒ è¿æ¥è¶…æ—¶ï¼Œæ£€æŸ¥ç½‘ç»œè¿æ¥');
            return { shouldRetry: true, delay: 3000 };
        });
        
        this.errorHandlers.set('EPIPE', (err) => {
            console.error('âŒ ç®¡é“ç ´è£‚ï¼ŒæœåŠ¡å™¨å¼‚å¸¸å…³é—­');
            return { shouldRetry: true, delay: 1000 };
        });
    }
    
    async connect() {
        if (this.connectionState === 'connecting') {
            console.warn('âš ï¸ è¿æ¥æ­£åœ¨è¿›è¡Œä¸­...');
            return;
        }
        
        this.connectionState = 'connecting';
        
        try {
            await this.establishConnection();
            this.connectionState = 'connected';
        } catch (err) {
            this.connectionState = 'disconnected';
            throw err;
        }
    }
    
    establishConnection() {
        return new Promise((resolve, reject) => {
            ipc.connectTo(this.serverId, () => {
                const socket = ipc.of[this.serverId];
                
                socket.on('connect', () => {
                    console.log('âœ… è¿æ¥å»ºç«‹æˆåŠŸ');
                    this.lastError = null;
                    resolve(socket);
                });
                
                socket.on('error', (err) => {
                    this.handleError(err, reject);
                });
                
                socket.on('disconnect', () => {
                    if (this.connectionState === 'connected') {
                        console.log('ğŸ”Œ è¿æ¥æ„å¤–æ–­å¼€');
                        this.connectionState = 'disconnected';
                        this.attemptReconnect();
                    }
                });
            });
        });
    }
    
    handleError(err, rejectCallback = null) {
        this.lastError = err;
        const errorCode = err.code || 'UNKNOWN';
        
        console.error(`âŒ IPCé”™è¯¯ [${errorCode}]:`, err.message);
        
        const handler = this.errorHandlers.get(errorCode);
        if (handler) {
            const result = handler(err);
            if (result.shouldRetry) {
                setTimeout(() => {
                    this.attemptReconnect();
                }, result.delay);
            }
        } else {
            console.error('âŒ æœªçŸ¥é”™è¯¯ç±»å‹:', errorCode);
        }
        
        if (rejectCallback) {
            rejectCallback(err);
        }
    }
    
    attemptReconnect() {
        if (this.connectionState !== 'disconnected') {
            return;
        }
        
        console.log('ğŸ”„ å°è¯•é‡æ–°è¿æ¥...');
        
        this.connect().catch(err => {
            console.error('é‡è¿å¤±è´¥:', err.message);
        });
    }
    
    getConnectionInfo() {
        return {
            serverId: this.serverId,
            state: this.connectionState,
            lastError: this.lastError ? {
                code: this.lastError.code,
                message: this.lastError.message,
                timestamp: new Date().toISOString()
            } : null
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const client = new RobustIPCClient('myServer');

client.connect()
    .then(() => {
        console.log('å®¢æˆ·ç«¯è¿æ¥æˆåŠŸ');
        
        // å®šæœŸæ£€æŸ¥è¿æ¥çŠ¶æ€
        setInterval(() => {
            const info = client.getConnectionInfo();
            console.log('è¿æ¥çŠ¶æ€:', info);
        }, 10000);
    })
    .catch(err => {
        console.error('åˆå§‹è¿æ¥å¤±è´¥:', err.message);
    });</code></pre>
        </div>

        <h2>6. å®é™…åº”ç”¨åœºæ™¯ç¤ºä¾‹</h2>

        <h3>6.1 å®æ—¶èŠå¤©å®¢æˆ·ç«¯</h3>
        <div class="example-section">
            <pre><code class="language-javascript">class ChatClient {
    constructor(username) {
        this.username = username;
        this.currentRoom = null;
        this.messageHistory = [];
        
        ipc.config.id = `chat-client-${username}`;
        ipc.config.retry = 1000;
    }
    
    async connect() {
        return new Promise((resolve) => {
            ipc.connectTo('chatServer', () => {
                this.socket = ipc.of.chatServer;
                
                this.socket.on('connect', () => {
                    console.log('ğŸ”— å·²è¿æ¥åˆ°èŠå¤©æœåŠ¡å™¨');
                    
                    // å‘é€ç”¨æˆ·è®¤è¯
                    this.socket.emit('authenticate', {
                        username: this.username,
                        timestamp: Date.now()
                    });
                });
                
                // è®¤è¯æˆåŠŸ
                this.socket.on('authenticated', (data) => {
                    console.log('âœ… è®¤è¯æˆåŠŸ');
                    this.userId = data.userId;
                    resolve();
                });
                
                // æ¥æ”¶æ¶ˆæ¯
                this.socket.on('message', (data) => {
                    this.handleMessage(data);
                });
                
                // ç”¨æˆ·åˆ—è¡¨æ›´æ–°
                this.socket.on('userList', (users) => {
                    this.updateUserList(users);
                });
                
                // æˆ¿é—´åˆ—è¡¨æ›´æ–°
                this.socket.on('roomList', (rooms) => {
                    this.updateRoomList(rooms);
                });
            });
        });
    }
    
    handleMessage(messageData) {
        const { from, to, content, timestamp, messageType } = messageData;
        
        const message = {
            id: Date.now() + Math.random(),
            from,
            to,
            content,
            timestamp: new Date(timestamp),
            type: messageType || 'text'
        };
        
        this.messageHistory.push(message);
        this.displayMessage(message);
        
        // ä¿æŒæ¶ˆæ¯å†å²åœ¨åˆç†èŒƒå›´å†…
        if (this.messageHistory.length > 1000) {
            this.messageHistory = this.messageHistory.slice(-500);
        }
    }
    
    sendMessage(content, targetUser = null) {
        if (!this.socket || !content.trim()) {
            return false;
        }
        
        const message = {
            content: content.trim(),
            timestamp: Date.now(),
            from: this.username,
            to: targetUser || this.currentRoom,
            messageType: targetUser ? 'private' : 'public'
        };
        
        this.socket.emit('sendMessage', message);
        return true;
    }
    
    joinRoom(roomName) {
        if (this.socket) {
            this.socket.emit('joinRoom', { roomName });
            this.currentRoom = roomName;
        }
    }
    
    leaveRoom() {
        if (this.socket && this.currentRoom) {
            this.socket.emit('leaveRoom', { roomName: this.currentRoom });
            this.currentRoom = null;
        }
    }
    
    displayMessage(message) {
        const timeStr = message.timestamp.toLocaleTimeString();
        const prefix = message.type === 'private' ? '[ç§èŠ]' : '';
        console.log(`${prefix}[${timeStr}] ${message.from}: ${message.content}`);
    }
    
    updateUserList(users) {
        console.log('ğŸ“‹ åœ¨çº¿ç”¨æˆ·:', users.map(u => u.username).join(', '));
    }
    
    updateRoomList(rooms) {
        console.log('ğŸ  æˆ¿é—´åˆ—è¡¨:', rooms.map(r => `${r.name}(${r.users}äºº)`).join(', '));
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const chatClient = new ChatClient('å¼ ä¸‰');

chatClient.connect().then(() => {
    // åŠ å…¥é»˜è®¤æˆ¿é—´
    chatClient.joinRoom('å¤§å…');
    
    // æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥
    setTimeout(() => chatClient.sendMessage('å¤§å®¶å¥½ï¼'), 1000);
    setTimeout(() => chatClient.sendMessage('æœ‰äººåœ¨å—ï¼Ÿ'), 3000);
});</code></pre>
        </div>

        <h3>6.2 åˆ†å¸ƒå¼ä»»åŠ¡å¤„ç†å®¢æˆ·ç«¯</h3>
        <div class="example-section">
            <pre><code class="language-javascript">class TaskWorkerClient {
    constructor(workerId, capabilities = []) {
        this.workerId = workerId;
        this.capabilities = capabilities;
        this.currentTasks = new Map();
        this.completedTasks = 0;
        this.isReady = false;
        
        ipc.config.id = `worker-${workerId}`;
        ipc.config.retry = 2000;
        ipc.config.maxRetries = 0; // æ— é™é‡è¯•
    }
    
    async connect() {
        return new Promise((resolve) => {
            ipc.connectTo('taskManager', () => {
                this.socket = ipc.of.taskManager;
                
                this.socket.on('connect', () => {
                    console.log(`ğŸ”— Worker ${this.workerId} è¿æ¥åˆ°ä»»åŠ¡ç®¡ç†å™¨`);
                    this.registerWorker();
                });
                
                this.socket.on('registered', (data) => {
                    if (data.success) {
                        console.log('âœ… Worker å·²æˆåŠŸæ³¨å†Œ');
                        this.isReady = true;
                        resolve();
                    } else {
                        console.error('âŒ Worker æ³¨å†Œå¤±è´¥:', data.message);
                    }
                });

                this.socket.on('newTask', (task) => {
                    if (this.isReady && this.capabilities.includes(task.type)) {
                        this.processTask(task);
                    } else if (!this.capabilities.includes(task.type)) {
                        console.warn(`âš ï¸ ä»»åŠ¡ç±»å‹ ${task.type} ä¸æ”¯æŒï¼Œå·²å¿½ç•¥`);
                        this.socket.emit('taskFailed', { taskId: task.id, error: 'Unsupported task type' });
                    }
                });

                this.socket.on('disconnect', () => {
                    console.log(`âŒ ä¸ä»»åŠ¡ç®¡ç†å™¨æ–­å¼€è¿æ¥`);
                    this.isReady = false;
                    // å°è¯•è‡ªåŠ¨é‡è¿
                    setTimeout(() => this.connect(), ipc.config.retry);
                });

                this.socket.on('error', (err) => {
                    console.error('Worker è¿æ¥é”™è¯¯:', err);
                });
            });
        });
    }

    registerWorker() {
        this.socket.emit('registerWorker', {
            workerId: this.workerId,
            capabilities: this.capabilities,
            status: 'idle'
        });
    }

    async processTask(task) {
        if (this.currentTasks.has(task.id)) {
            return; // ä»»åŠ¡å·²åœ¨å¤„ç†ä¸­
        }

        console.log(`ğŸš€ å¼€å§‹å¤„ç†ä»»åŠ¡ ${task.id} (ç±»å‹: ${task.type})`);
        this.currentTasks.set(task.id, task);
        this.socket.emit('taskStarted', { taskId: task.id });

        try {
            // æ¨¡æ‹Ÿä»»åŠ¡æ‰§è¡Œ
            await new Promise(resolve => setTimeout(resolve, task.duration || 2000));
            const result = `Task ${task.id} processed successfully.`;
            
            this.completedTasks++;
            console.log(`âœ… ä»»åŠ¡ ${task.id} å®Œæˆ`);
            this.socket.emit('taskCompleted', { taskId: task.id, result: result });
        } catch (error) {
            console.error(`âŒ ä»»åŠ¡ ${task.id} æ‰§è¡Œå¤±è´¥:`, error);
            this.socket.emit('taskFailed', { taskId: task.id, error: error.message });
        } finally {
            this.currentTasks.delete(task.id);
        }
    }

    // æ›´å¤šæ–¹æ³•ï¼Œä¾‹å¦‚è·å–å·¥ä½œçŠ¶æ€ç­‰
    getWorkerStatus() {
        return {
            workerId: this.workerId,
            isReady: this.isReady,
            processingTasks: this.currentTasks.size,
            completedTasks: this.completedTasks,
            capabilities: this.capabilities
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const worker1 = new TaskWorkerClient('worker-001', ['image_resize', 'text_process']);
const worker2 = new TaskWorkerClient('worker-002', ['data_export']);

Promise.all([worker1.connect(), worker2.connect()]).then(() => {
    console.log('æ‰€æœ‰ Worker å·²è¿æ¥å¹¶å‡†å¤‡å°±ç»ªã€‚');
});</code></pre>
        </div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>